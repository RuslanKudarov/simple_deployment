# импортируем библиотеки
import pandas as pd
import numpy as np
import streamlit as st

# импортируем пакет
import dill


# загрузим ранее сохраненный конвейер
with open('pipeline_for_deployment.pkl', 'rb') as f:
    pipe = dill.load(f)

# функция запуска веб-интерфейса
def run():
    from PIL import Image
    image = Image.open('logo.jpg')
    
    st.sidebar.image(image)
    
    question = ("В каком режиме вы хотели бы сделать прогноз, Онлайн\n"
               "(Online) или загрузкой файла данных(Batch)?")
    
    add_selectbox = st.sidebar.selectbox(question, ("Online", "Batch"))
    
    sidebar_ttl = ("Прогнозирование неуспеваемости с использованием\n"
                  "метода логистической регрессии.")
    
    st.sidebar.info(sidebar_ttl)
    st.title("Прогнозирование неуспеваемости:")
    
    if add_selectbox == "Online":
        
        Gender = st.radio('Пол студента', ["М", "Ж"],
                          index = 0, horizontal = True)
        Obshezitie = []
        Grazdanstvo = []
        Inostranec = []
        TipDogovora = []
        VidZatrat = []
        CelevoiPriem = []
        Facultet = []
        NapravleniePodgotovki = []
        SrokObucheniya = []
        Obrazovanie = []
        SdavalEge = []
        SrBallDokObr = 3
        EgeMath = 36
        EgeRus = st.slider('Русский язык ЕГЭ', min_value = 36, max_value = 100,
                          value = 36, step = 1)
                #EgeRus = st.number_input('Русский язык ЕГЭ', step = 1,
        #                        min_value = 36, max_value = 100,
        #                        value = 36, help = 'введите от 36 до 100')
        Obr = ['']
        
        input_dict = {
            'Пол': Gender,
            'Нуждается в общежитии': Obshezitie,
            'Гражданство': Grazdanstvo,
            'Иностранец': Inostranec,
            'Тип договора': TipDogovora,
            'Вид затрат': VidZatrat,
            'Целевой прием': CelevoiPriem,
            'Факультет': Facultet,
            'Направление подготовки': NapravleniePodgotovki,
            'Срок обучения': SrokObucheniya,
            'Полученное образование': Obrazovanie,
            'Сдавал ЕГЭ': SdavalEge,
            'Ср. балл док-та об образовании': SrBallDokObr,
            'Математика ЕГЭ': EgeMath,
            'Русский язык ЕГЭ': EgeRus
        }
        input_df = pd.DataFrame([input_dict])
        
        if st.button("Спрогнозировать вероятность неуспеваемости"):
            
            # выделим категориальные переменные
            categoric_columns = [c for c in input_df.columns if input_df[c].dtype.name == 'object']

            # присвоим категориальным переменным тип str
            # тип str формирует для пропусков отдельную категорию nan
            for c in categoric_columns:
                if c in input_df.columns:
                    input_df[c] = input_df[c].astype('str')

            # создадим функцию обработки
            # категорий переменной 'Полученное образование'
            # в зависимости от года набора
            def GodNabora(year):
                return year
            def Nabor(GodNabora):
                Edu = input_df.copy()
                # запишем словарь переименования возможныж категорий
                d = {'Среднее общее образование, {} г.'.format(GodNabora):'Среднее общее образование, получено в год поступления',
                'Среднее общее образование, {} г.'.format(GodNabora-1):'Среднее общее образование, получено за год до поступления',
                'Среднее общее образование, {} г.'.format(GodNabora-2):'Среднее общее образование, получено за два года до поступления',
                'Среднее общее образование, {} г.'.format(GodNabora-3):'Среднее общее образование, получено за три года до поступления',
                'Среднее профессиональное образование, {} г.'.format(GodNabora):'Среднее профессиональное образование, получено в год поступления',
                        'Другое образование':'Другое образование', 'nan':'nan'}
                # заменим категории по словарю
                Edu['Полученное образование'] = Edu['Полученное образование'].map(d)
                # объединим категории переменной 'Полученное образование'
                # в категорию 'Другое образование' кроме категорий
                # 'Среднее общее образование, получено в год поступления'
                # 'Среднее общее образование, получено за год до поступления'
                # 'Среднее общее образование, получено за два года до поступления'
                # 'Среднее общее образование, получено за три года до поступления'
                # 'Среднее профессиональное образование, получено в год поступления'
                # 'nan'
                Edu['Полученное образование'] = [x if x in ['Среднее общее образование, получено в год поступления',
                                                           'Среднее общее образование, получено за год до поступления',
                                                           'Среднее общее образование, получено за два года до поступления',
                                                           'Среднее общее образование, получено за три года до поступления',
                                                           'Среднее профессиональное образование, получено в год поступления',
                                                           'nan']
                                                else 'Другое образование'
                                                for x in Edu['Полученное образование']]
                return Edu['Полученное образование']

            # создадим функцию объединения редких категорий
            # независимой переменной 'Гражданство'
            # в зависимости от размера наименьшей допустимой категории
            # задаваемой в % от объема всей выборки
            def PercentRestOfWorld(percent):
                return percent
            def RestOfWorld(PercentRestOfWorld):
                Nation = input_df.copy()
                Nation['Гражданство'][Nation.groupby('Гражданство')['Гражданство'].transform('count') < PercentRestOfWorld * len(Nation) / 100] = 'Другие страны'   
                return Nation['Гражданство']

            # создадим фукнцию порога исключения из анализа независимых переменных
            # у которых доля битых данных первышает этот порог
            # задаваемый в % от объемах всей выборки
            def OutOfAnalysis(threshold):
                return threshold / 100

            # запишем функцию предварительной обработки данных
            def preprocessing(df, GodNabora, PercentRestOfWorld, OutOfAnalysis):

                # назначим синий цвет сообщениям
                def out_red(text):
                    print("\033[34m{}".format(text))
                out_red("")

                # сообщим о категориях переменной 'Полученное образование'
                print("Наименование категорий для {:.0f} года набора:".format(GodNabora))
                print(Nabor(GodNabora).value_counts())

                # назначим зеленый цвет сообщениям
                def out_red(text):
                    print("\033[32m{}".format(text))
                out_red("")

                # сообщим о категориях переменной 'Гражданство'
                print("Объединение категорий с частотами меньше {:.0f}% от объема всей выборки:".format(PercentRestOfWorld))
                print(RestOfWorld(PercentRestOfWorld).value_counts())

                # выделим категориальные переменные
                categorical_columns = [c for c in df.columns if df[c].dtype.name == 'object']
                del categorical_columns[0:2]

                # выделим количественные переменные
                numerical_columns = [c for c in df.columns if df[c].dtype.name != 'object']

                # заполним датафрейм обработанными данными
                df['Полученное образование'] = Nabor(GodNabora)
                df['Гражданство'] = RestOfWorld(PercentRestOfWorld)

                # заменим пропуски в категориальных переменных нулями
                for c in categorical_columns:
                    df[c] = np.where((df[c] == 'nan'), 0, df[c])

                # заменим пропуски и значения меньше 3 баллов
                # независимой переменной 'Ср. балл док-та об образовании'
                # значением 0 баллов
                df['Ср. балл док-та об образовании'] = np.where((df['Ср. балл док-та об образовании'].isnull()) |
                                                             (df['Ср. балл док-та об образовании'] < 3),
                                                             0,
                                                             df['Ср. балл док-та об образовании'])
                # заменим пропуски и значения меньше 36 баллов
                # независимых переменных 'Русский язык ЕГЭ' и 'Математика ЕГЭ'
                # значением 0 баллов
                df['Русский язык ЕГЭ'] = np.where((df['Русский язык ЕГЭ'].isnull()) |
                                                             (df['Русский язык ЕГЭ'] < 36),
                                                             0,
                                                             df['Русский язык ЕГЭ'])
                df['Математика ЕГЭ'] = np.where((df['Математика ЕГЭ'].isnull()) |
                                                             (df['Математика ЕГЭ'] < 36),
                                                             0,
                                                             df['Математика ЕГЭ']) 

                # преобразуем независимые переменные 'Русский язык ЕГЭ' и 'Математика ЕГЭ' 
                # из типа float в тип int
                for i in ['Русский язык ЕГЭ', 'Математика ЕГЭ']:
                    if i in df.columns:
                        df[i] = df[i].astype('int64')       

                # назначим красный цвет сообщениям 
                def out_red(text):
                    print("\033[31m{}".format(text))
                out_red("")

                # сообщим об исключении переменных из анализа
                print("Исключены из анализа переменные с более {:.0f}% битых данных:".format(OutOfAnalysis * 100))

                # исключены из анализа независимые переменные
                # с числом нулевых значений больше порогового % от объема выборки
                for c in df:
                    if len(df[df[c] == 0]) > OutOfAnalysis * len(df):
                        print(c, "-", len(df[df[c] == 0]), "пропусков")
                        del df[c]
                print('*** конец списка ***')

                return df         
            
            # выполняем предварительную обработку новых данных
            preprocessing(input_df, GodNabora(2023), PercentRestOfWorld(2), OutOfAnalysis(50))
            # вычисляем вероятности для новых данных
            output = pipe.predict_proba(input_df)[:, 1]
            output = str(output)
            st.success("Вероятность неуспеваемости: {}".format(output))
        
    if add_selectbox == "Batch":
        
        file_upload_ttl = ("Загрузите csv-файл с новыми данными\n"
                          "для вычисления вероятностей:")
        file_upload = st.file_uploader(file_upload_ttl, type = ['csv'])
        
        if file_upload is not None:
            newdata = pd.read_csv(file_upload, sep = ';')
            
            # выделим категориальные переменные
            categoric_columns = [c for c in newdata.columns if newdata[c].dtype.name == 'object']

            # присвоим категориальным переменным тип str
            # тип str формирует для пропусков отдельную категорию nan
            for c in categoric_columns:
                if c in newdata.columns:
                    newdata[c] = newdata[c].astype('str')

            # создадим функцию обработки
            # категорий переменной 'Полученное образование'
            # в зависимости от года набора
            def GodNabora(year):
                return year
            def Nabor(GodNabora):
                Edu = newdata.copy()
                # запишем словарь переименования возможныж категорий
                d = {'Среднее общее образование, {} г.'.format(GodNabora):'Среднее общее образование, получено в год поступления',
                'Среднее общее образование, {} г.'.format(GodNabora-1):'Среднее общее образование, получено за год до поступления',
                'Среднее общее образование, {} г.'.format(GodNabora-2):'Среднее общее образование, получено за два года до поступления',
                'Среднее общее образование, {} г.'.format(GodNabora-3):'Среднее общее образование, получено за три года до поступления',
                'Среднее профессиональное образование, {} г.'.format(GodNabora):'Среднее профессиональное образование, получено в год поступления',
                        'Другое образование':'Другое образование', 'nan':'nan'}
                # заменим категории по словарю
                Edu['Полученное образование'] = Edu['Полученное образование'].map(d)
                # объединим категории переменной 'Полученное образование'
                # в категорию 'Другое образование' кроме категорий
                # 'Среднее общее образование, получено в год поступления'
                # 'Среднее общее образование, получено за год до поступления'
                # 'Среднее общее образование, получено за два года до поступления'
                # 'Среднее общее образование, получено за три года до поступления'
                # 'Среднее профессиональное образование, получено в год поступления'
                # 'nan'
                Edu['Полученное образование'] = [x if x in ['Среднее общее образование, получено в год поступления',
                                                           'Среднее общее образование, получено за год до поступления',
                                                           'Среднее общее образование, получено за два года до поступления',
                                                           'Среднее общее образование, получено за три года до поступления',
                                                           'Среднее профессиональное образование, получено в год поступления',
                                                           'nan']
                                                else 'Другое образование'
                                                for x in Edu['Полученное образование']]
                return Edu['Полученное образование']

            # создадим функцию объединения редких категорий
            # независимой переменной 'Гражданство'
            # в зависимости от размера наименьшей допустимой категории
            # задаваемой в % от объема всей выборки
            def PercentRestOfWorld(percent):
                return percent
            def RestOfWorld(PercentRestOfWorld):
                Nation = newdata.copy()
                Nation['Гражданство'][Nation.groupby('Гражданство')['Гражданство'].transform('count') < PercentRestOfWorld * len(Nation) / 100] = 'Другие страны'   
                return Nation['Гражданство']

            # создадим фукнцию порога исключения из анализа независимых переменных
            # у которых доля битых данных первышает этот порог
            # задаваемый в % от объемах всей выборки
            def OutOfAnalysis(threshold):
                return threshold / 100

            # запишем функцию предварительной обработки данных
            def preprocessing(df, GodNabora, PercentRestOfWorld, OutOfAnalysis):

                # назначим синий цвет сообщениям
                def out_red(text):
                    print("\033[34m{}".format(text))
                out_red("")

                # сообщим о категориях переменной 'Полученное образование'
                print("Наименование категорий для {:.0f} года набора:".format(GodNabora))
                print(Nabor(GodNabora).value_counts())

                # назначим зеленый цвет сообщениям
                def out_red(text):
                    print("\033[32m{}".format(text))
                out_red("")

                # сообщим о категориях переменной 'Гражданство'
                print("Объединение категорий с частотами меньше {:.0f}% от объема всей выборки:".format(PercentRestOfWorld))
                print(RestOfWorld(PercentRestOfWorld).value_counts())

                # выделим категориальные переменные
                categorical_columns = [c for c in df.columns if df[c].dtype.name == 'object']
                del categorical_columns[0:2]

                # выделим количественные переменные
                numerical_columns = [c for c in df.columns if df[c].dtype.name != 'object']

                # заполним датафрейм обработанными данными
                df['Полученное образование'] = Nabor(GodNabora)
                df['Гражданство'] = RestOfWorld(PercentRestOfWorld)

                # заменим пропуски в категориальных переменных нулями
                for c in categorical_columns:
                    df[c] = np.where((df[c] == 'nan'), 0, df[c])

                # заменим пропуски и значения меньше 3 баллов
                # независимой переменной 'Ср. балл док-та об образовании'
                # значением 0 баллов
                df['Ср. балл док-та об образовании'] = np.where((df['Ср. балл док-та об образовании'].isnull()) |
                                                             (df['Ср. балл док-та об образовании'] < 3),
                                                             0,
                                                             df['Ср. балл док-та об образовании'])
                # заменим пропуски и значения меньше 36 баллов
                # независимых переменных 'Русский язык ЕГЭ' и 'Математика ЕГЭ'
                # значением 0 баллов
                df['Русский язык ЕГЭ'] = np.where((df['Русский язык ЕГЭ'].isnull()) |
                                                             (df['Русский язык ЕГЭ'] < 36),
                                                             0,
                                                             df['Русский язык ЕГЭ'])
                df['Математика ЕГЭ'] = np.where((df['Математика ЕГЭ'].isnull()) |
                                                             (df['Математика ЕГЭ'] < 36),
                                                             0,
                                                             df['Математика ЕГЭ']) 

                # преобразуем независимые переменные 'Русский язык ЕГЭ' и 'Математика ЕГЭ' 
                # из типа float в тип int
                for i in ['Русский язык ЕГЭ', 'Математика ЕГЭ']:
                    if i in df.columns:
                        df[i] = df[i].astype('int64')       

                # назначим красный цвет сообщениям 
                def out_red(text):
                    print("\033[31m{}".format(text))
                out_red("")

                # сообщим об исключении переменных из анализа
                print("Исключены из анализа переменные с более {:.0f}% битых данных:".format(OutOfAnalysis * 100))

                # исключены из анализа независимые переменные
                # с числом нулевых значений больше порогового % от объема выборки
                for c in df:
                    if len(df[df[c] == 0]) > OutOfAnalysis * len(df):
                        print(c, "-", len(df[df[c] == 0]), "пропусков")
                        del df[c]
                print('*** конец списка ***')

                return df         
            
            # выполняем предварительную обработку новых данных
            preprocessing(newdata, GodNabora(2023), PercentRestOfWorld(2), OutOfAnalysis(50))
            
            # вычисляем вероятности для новых данных
            prob = pipe.predict_proba(newdata)[:, 1]
            prob_id = newdata[['ФИО', 'Группа']]
            prob_id.insert(loc = 2, column = 'Вероятность неуспеваемости', value = prob)
            
            # вывод вероятностей на веб-странице
            st.success("Вероятности просрочки для загруженных данных:")
            st.write(prob_id)
            
if __name__ == '__main__':
    run()